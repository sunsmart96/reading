# 图解http

这本书是一个日本人写的。这本书几年前我就看过了，大部分知识我早就用过。因为做后端开发，大量的接口协议都是用http的。只不过因为我手里的纸质书实在太多，每次搬家都很麻烦，而且有的书籍对于现在的我已经没什么提升了，因为我会把这些纸质书送给自己的粉丝。目前接近一年的时间已经送出去接近50本了。而我送出去的书本身也是我读过消化掉的书籍。这也从另一个方面督促我自己能不断地看书学习不同方向的知识，不至于思维固化。读书学习总需要一些动力，有人说督促人们做事用最原始的欲望去引导他们，这固然是一种办法，但是我想一个更高级的合作共赢是我可以行得通的。



这个系列还有其他方向的书籍，特点都是一致的，就是用图解的方式比较生动形象地介绍一些工程技术的概念和方法。我之前送出去两本关于哲学入门的书籍也是日本人写的，我认为写的非常棒，非常简洁的介绍世界古今中外不同哲学流派的哲学观点。



对于数学、科学、技术、哲学思想、社会科学等领域的书籍，我一直都坚持看外国资料为主，很少看中国的书籍(中文翻译的外国书籍不算中国书籍)。即使看中国的书籍，我大多也是看古籍比如先秦诸子百家、史记、资治通鉴。技术方面更是如此。坦率来讲，最近十几年来看，中国国内技术类书籍，尤其计算机类的书籍，在产业界人写的书的实用性远远高于在学术界人写的，如果是教材，国内的书籍十篇至少有九篇以上都是垃圾，说是误人子弟一点都不为过。也不是说内容是错的，而是如果你是一个初学者，你想学习，不好意思，你看他的书你是学不会的。但是如果你已经学会了，再看看他的书，发现写的倒也对。



我去选择一本书看，自然是想学习里面的知识，我当然是小白。但是大量国产教科书都没把我当小白，这种教科书除了背诵刷点题应付考试，一点用都没有。如果是人文社科，更是经常出现狗屁不通的逻辑，似是而非的论述。看着就让人想睡觉。我曾一度被这种国产“毒教材”坑的怀疑人生。让我对自己有一个很深的怀疑，难道是我智商不够，还是我能力不足亦或是我不够努力？



当我存在这种疑惑，去寻找周围人的帮助时，我面对的大多都是批评。没有具体问题具体分析的额引导，都是直接攻击我贪玩，学习方法不对，甚至说我有病。在局限于一个狭隘的小圈子里面的时候，我真的深深怀疑过自己。甚至一度就认为自己就是纯纯的垃圾。直到我后面去中科院读研，因为中科院大量很多优秀的老师都是海外回来的，都是直接给我看海外原版的英文书籍，起初外语不好，直接看全英文很吃力，时间久了，就发现这里面的门道了。原来问题不是出在我身上，而是用的书籍不对。于是我开始大量接触各种海外留学回来的人，不论是教授还是企业，受益良多。



再往后，就开始经常用知乎这个软件，这个软件早些年关于学习的资料路径那真是一个全面，还不像现在这样各种情绪输出、回答水平低同质化严重，大量优质知识分子博主流失不再分享优质知识内容前沿科技内容。曾经那种万物经发勃勃生机已经不在。



正是我的这种经历，让我对国外的资料极为重视。通过这些东西，也极大地提升了我的能力水平认知。而我之前在国内院校学习或者在公司企业就业所给我带来的成长远没有这些大。



# 0.前言

HTTP到2025年为止主要有三个版本分为1、2、3。这本书主要基于1的版本。http这块不像大不多计算机软件版本协议，一个大版本出来之后，旧的版本基本就逐步没人用了。这本书是十多年前写的，现在虽然出了http2和3的版本，但是很多web项目依然会使用http1的协议。因为新版本都是针对旧版本有升级的，但是旧版本已经可以解决大部分常规问题了，所以使用依然广泛。除非碰到比较苛刻的场景，才会去升级使用新的版本。亦或是就是针对web的创新性产品，比如很多web3应用，才会直接用新的版本。

就我自己经历而言，即使在2025年很多私有云部署，内部都是还是用http1的主力版本。就看具体产品需求了。



# 1.了解web及网络基础

http底层使用的是tcp/ip协议族，网络协议这块按照不同的划分标准有五层和七层之分。应用层主要是各种引用协议，反正在日常网络编程中开发引用程序大部分协议都是这个层的。比如http、https、ftp、dns、ssh、mqtt等等。



http网络数据传输首先按照协议栈的不同分层进行封装，http的数据报文存在tcp的报文段，tcp再自己加上自己头文件数据，封装到网络包中，网络包也要加上自己的首部，然后装进数据链路包中。



http中的网址要用过dns解析成具体ip信息，负责传输的ip协议，但是ip协议也依赖底层的mac地址协议。ip是节点被分配的地址，而mac是网卡所属的固定地址。ip传输数据的时候，是通过路由，去寻找目标ip地址。可靠传输这块用tcp。当然比较新的http3也可以使用udp加一些机制来保证可靠传输的同时，提高传输速度。



tcp通信开始的时候要有三次握手。客户端向服务端发送syn，服务端受到syn并返回syn/ack,客户端收到之后再返回一个ack。这块好像是程序员网络编程必考题。DNS就是把域名转成ip地址，因为ip地址太难记忆了。域名更好记忆。尤其ipv6，那一大串没人记得住。



URI------统一资源标识符

URL------统一资源定位符

URI比URL范围更大一点。因为它不止包含文件，也包含文件里面的对象



# 2.简单的http协议

http客户端和服务端通过请求响应的方式完成通信。http协议不是保持状态的协议，也就是说通信完成一次后，下一次通信本身并不保持之前通信的状态。但是后面互联网又发展，比如比登录一个网站，肯定登录一次就完事了，不想跳转一个页面后，还得重新登录，所以http引入cookie，可以保存之前的登录信息状态。



http内置多种方法，不同的方法跟服务器通信后服务器端的行为不同。

GET方法---获取服务端信息资源，不改变服务端

POST方法---传输消息给服务端福并让服务端执行一些改变自身的行为

PUT方法---传输文件

HEAD方法---获得报文首部

DELETE方法---删除文件

OPTIONS方法---询问支持的方法

TRACE方法---追踪路径

CONNECT方法---要求使用隧道协议连接代理



如果每次连接http通信都重新连接tcp，就会导致大量时间资源都用于重连，所以可以使用keep-alive保证在客户端或者服务端明确断连前，都保持tcp连接。



客户端会从服务端获得一个Set-Cookie首部字段信息。把这个信息保存在客户端，然后下次给服务端发送信息加上这个字段，服务端会根据这个信息，在服务端检查消息到底属于哪个客户端。



# 3.http报文内的http信息

客户端发的叫做请求报文，服务端发的是响应报文。结构都是报文头部加空行加报文主体。

http可以通过指定编码的方式，对数据进行压缩，到接收方再解压来提高通信效率。

http也可以同时发送多个不同的实体。也可以获取部分请求范围。

http可以通过内容协商返回不同的内容。比如说显示语言。



# 4.返回结果的http状态码

状态码返回服务端给客户端请求结果，就是硬编码的一些代码，表示成功、失败、什么原因的失败。



1xx---信息状态码---接收的请求正在处理

2xx---成功状态码---请求正常处理完毕

3xx---重定向状态码---需要进行附加操作以完成请求

4xx---客户端错误状态码---服务端无法处理请求

5xx---服务端错误状态码---服务端处理请求出错



| 200 | ok                              |
| --- | ------------------------------- |
| 204 | 请求得到处理但是没有资源返回                  |
| 206 | 范围请求                            |
| 301 | 永久从定向                           |
| 302 | 临时重定向                           |
| 303 | 请求的资源存在另一个uri，应使用GET方法定向获取请求的资源 |
| 304 | 资源已找到，但是未符合条件请求                 |
| 307 | 临时重定向                           |
| 400 | 无法理解这个请求                        |
| 401 | 第一次返回401，弹出认证界面，第二次返回401表示认证失败  |
| 403 | 请求被服务端拒绝                        |
| 404 | 服务器没有该资源                        |
| 500 | 服务端执行请求发生故障                     |
| 503 | 服务端处于超负荷或者停机维护                  |



# 5.与http协作的服务器

单台物理主机可以运行多个服务，提供多个域名。这种叫做虚拟服务器。



代理---位于客户端和服务器之间，转发二者通信

网关---转发其他服务器通信数据的服务器，代理主要是http协议，而网关可以有更广泛协议

隧道---主要用来加密



缓存服务器---把服务端资源提前缓存到缓存服务器，等到客户端需要，直接访问缓存服务器即可。可以降低核心服务器带宽压力。



# 6.http首部

就是各种配置元信息



请求报文---包含方法、URI、HTTP版本、HTTP首部字段

相应报文---HTTP版本、状态码、HTTP首部字段



首部字段类型

通用首部字段---请求报文和响应报文都会使用的首部

请求首部字段---专用于请求的

响应首部字段---专用于响应的

实体首部字段---实体部分使用的首部



由于http的现实实现并不只局限于RFC2616,所以首部字段也会有参考其他RFC的文档定义。



这本书我五年前就看过，但是当时看没怎么注意RFC这种文档定义。后来我去了一家自动驾驶的明星创业公司，里面对于一些软件的改进都喜欢以RFC命名。我当时也不太懂只是照葫芦画瓢。后来深入看了一下一些开源操作系统日常开发维护的模式，才发现这是已经在开源界使用了好久的约定。



## 6.1.通用首部字段

| Cache-Control     | 操作缓存的工作机制                  |
| ----------------- | -------------------------- |
| Connection        | 控制不再转发给代理的首部字段；管理持久连接      |
| Date              | 创建http报文时间                 |
| Trailer           | 事先说明在报文主体后记录了哪些字段          |
| Transfer-Encoding | 传输报文主体使用的编码方式，http1.1仅支持分块 |
| Upgrade           | 检测http协议及其他协议是否使用更高的版本进行通信 |
| Via               | 通过代理或者网关的时候在该字段加上服务器信息     |
| Warning           | 关于缓存相关的警告                  |

## 6.2.请求首部字段

| Accept              | 通知服务端用户代理能够处理的媒体类型和媒体类型优先级，媒体类型分为各种文本、图片、视频、二进制 |
| ------------------- | ----------------------------------------------- |
| Accept-CharSet      | 通知服务器用户代理支持的字符集和字符集的优先级                         |
| Accept-Encoding     | 通知服务器用户代理支持的内容编码和内容编码优先级                        |
| Accept-Language     | 通知服务器用户代理支持的语言集和语言集优先级                          |
| Authorization       | 发给服务端的认证信息                                      |
| Expect              | 通知服务端期望服务端出现的某种特定行为                             |
| Form                | 用户代理的电子邮箱                                       |
| Host                | 同一个ip的多个虚拟主机提供服务的时候用此字段区分不同服务                   |
| If-Match            | 服务器判断条件为真才会处理请求                                 |
| If-Modified-Since   | 指定日期之后发生了变更则处理请求                                |
| If-None-Match       | 服务端校验如果没有满足条件则处理请求                              |
| If-Range            | 如果字段跟ETag变更时间匹配则处理请求                            |
| If-Unmodified-Since | 如果字段跟ETag变更时间不匹配则处理请求                           |
| Max-Forwards        | 设置使用中间代理的最大中专次数，如果每次使用一个代理服务器就减1，直到为0就返回        |
| Proxy-Authorization | 客户端跟代理服务器之间的认证                                  |
| Range               | 指定分段获取资源的范围                                     |
| Referer             | 通知服务器请求的原始资源uri                                 |
| TE                  | 通知服务器客户端能够相应的传输编码方式                             |
| User-Agent          | 用户代理信息                                          |



## 6.3.响应首部字段

| Accept-Ranges       | 通知客户端服务端是否能处理范围请求                                |
| ------------------- | ------------------------------------------------ |
| Age                 | 通知客户端服务器多久前创建了响应                                 |
| ETag                | 服务端资源的标识，强ETag值只要资源发生任何改变都改变，弱ETag值资源不发生根本性改变就不变 |
| Location            | 配合重定向用                                           |
| Proxy-Authorization | 把代理服务器所要求的认证信息返给客户端                              |
| Server              | 服务端应用程序信息                                        |
| Vary                | 代理服务器用于确定缓存标识。匹配的话直接从代理服务器返回结果                   |
| WWW-Authenticate    | 返回给客户端告诉它认证方案是什么                                 |



## 6.4.实体首部字段

请求报文和响应报文实体部分的首部

| Allow            | 通知客户端服务端所支持的方法    |
| ---------------- | ----------------- |
| Content-Encoding | 实体部分内容编码          |
| Content-Language | 实体部分使用的自然语言       |
| Content-Length   | 实体部分大小            |
| Content-Location | 报文主体部分uri         |
| Content-MD5      | 报文主体部分的md5值       |
| Content-Range    | 告知客户端范围           |
| Content-Type     | 实体对象内媒体对象类型       |
| Expires          | 源服务器将资源失效的日期告诉客户端 |
| Last-Modified    | 资源最终修改时间          |



# 7.确保web更安全的https

通信使用明文会被窃听。使用抓包工具wireshark可以在网络上抓取http请求和响应。

防止被窃听，可以通信加密或者内容加密，防止伪装可以用证书验证。



https通过ssl跟tcp通信。

对称密钥加密是加密解密都用相同的密钥。非对称密钥使用公开密钥进行加密，使用私有密钥进行解密。使用https形式加密数据也会造成通信速度下降，两端计算资源消耗大一些的问题。



# 8.确认访问用户身份的认证

密码、动态令牌、数字证书、生物认证、IC卡



# 9.基于http的追加协议

消除http瓶颈的SPDY：Ajax/Comet/SPDY



双工通信websocket：双向，减少通信量，长连接



http2.0写这本书的时候，没正式出，现在已经完全推开了。3.0都已经出了很多应用。



# 10.构建web内容的技术

html、jave，json等等现在都很常用的web工具语言等



# 11.web攻击技术

主动攻击:sql注入、os命令注入

首部注入攻击，截断攻击等等吧，web攻防这块不太熟悉。



# 12.总结

这本书好多年前我就看过，里面很多基础知识在写后端程序的时候会用到。不过也有一些知识我不太用，比如web安全这块。另外我之前看也是只看了一部分，就去应付现实开发任务去了。所以这次在这本书送出去之前抽空再看看。因为我强迫自己每看完一本书，就必须写一篇文章。所以这篇文章其实写的很水。很多高级语言是直接在标准库内置了http协议接口的，比如python、golang。c和c++没有支持，需要调用第三方库。如libcurl、cpp-httplib等，如果真想精通，可以参考一些开源代码以及在实践中，去体会，尤其在互联网大厂，做相关业务，可以很快获得深刻的认知。







